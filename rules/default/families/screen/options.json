{
  "contentType": "application/vnd.gorules.decision",
  "nodes": [
    {
      "id": "scr-opt-input",
      "name": "Input",
      "type": "inputNode",
      "position": {
        "x": 100,
        "y": 300
      }
    },
    {
      "id": "scr-opt-fn",
      "name": "Screen Options",
      "type": "functionNode",
      "position": {
        "x": 400,
        "y": 300
      },
      "content": {
        "source": "/**\n * Screen Options — 15+ constraint rules\n * @type {Handler}\n */\nexport const handler = async (input) => {\n  const { userSelections: sel, specs, productType } = input;\n  const availableOptions = {};\n  const resetFields = [];\n  const variant = productType?.variant || 'standard';\n  const variantSpec = specs?.variant?.constraints || {};\n  const area = (sel.width && sel.height) ? (sel.width * sel.height) / 1000000 : 0;\n\n  // ── STEP 2: Fabric ──────────────────────────────────────────────────\n\n  // fabricType: filter by max area (rule 3)\n  if (specs?.fabric) {\n    availableOptions.fabricType = Object.entries(specs.fabric).map(([code, fs]) => {\n      let available = true;\n      let reason = null;\n      if (area > 0 && fs.maxArea && area > fs.maxArea) {\n        available = false;\n        reason = `Maximaal oppervlak ${fs.maxArea}m² (huidig: ${area.toFixed(1)}m²)`;\n      }\n      return { code, available, reason };\n    });\n    if (sel.fabricType) {\n      const ftOpt = availableOptions.fabricType.find(f => f.code === sel.fabricType);\n      if (ftOpt && !ftOpt.available) resetFields.push('fabricType', 'fabricColor', 'meshOpenness');\n    }\n  }\n\n  // fabricColor: filter by fabric type (rule 1)\n  if (sel.fabricType && specs?.fabric?.[sel.fabricType]) {\n    const allowed = specs.fabric[sel.fabricType].colors || [];\n    const allColors = [\n      'SCR-WHITE','SCR-LINEN','SCR-SAND','SCR-PEARL-GREY','SCR-SILVER',\n      'SCR-ALU-GREY','SCR-CHARCOAL','SCR-BLACK','SCR-BRONZE','SCR-BROWN',\n      'SCR-DARK-GREY','SCR-CREAM','SCR-BEIGE','SCR-LIGHT-GREY','SCR-TAUPE',\n      'SCR-STEEL','SCR-MOSS','SCR-NAVY','SCR-COFFEE','SCR-TERRACOTTA',\n      'SCR-OFF-WHITE','SCR-GRAPHITE','SCR-IVORY','SCR-STONE','SCR-MIDNIGHT'\n    ];\n    availableOptions.fabricColor = allColors.map(c => ({\n      code: c,\n      available: allowed.includes(c),\n      reason: allowed.includes(c) ? null : `Niet beschikbaar voor ${sel.fabricType}`\n    }));\n    if (sel.fabricColor && !allowed.includes(sel.fabricColor)) {\n      resetFields.push('fabricColor');\n    }\n  }\n\n  // meshOpenness: filter by fabric type (rule 2)\n  if (sel.fabricType && specs?.fabric?.[sel.fabricType]) {\n    const allowed = specs.fabric[sel.fabricType].openness || [];\n    const allOpenness = ['1','3','5','10','14'];\n    availableOptions.meshOpenness = allOpenness.map(o => ({\n      code: o,\n      available: allowed.includes(o),\n      reason: allowed.includes(o) ? null : `Niet beschikbaar voor ${sel.fabricType}`\n    }));\n    if (sel.meshOpenness && !allowed.includes(sel.meshOpenness)) {\n      resetFields.push('meshOpenness');\n    }\n  }\n\n  // ── STEP 3: Frame & Housing ─────────────────────────────────────────\n\n  // frameColor: always all 12 available\n  availableOptions.frameColor = [\n    'RAL9010','RAL9001','RAL9016','RAL7016','RAL7035','RAL7021',\n    'RAL8014','RAL8017','RAL9005','DB703','RAL7022','RAL8019'\n  ].map(c => ({ code: c, available: true, reason: null }));\n\n  // housingType: large sizes disable small housings (rule 4)\n  if (specs?.housing?.size_constraints) {\n    const hSpec = specs.housing.size_constraints;\n    const allHousings = ['square_100','round_100','square_120','round_120','concealed'];\n    availableOptions.housingType = allHousings.map(h => {\n      let available = true;\n      let reason = null;\n      // Rule 4: >3m width → no 100mm housing\n      if (sel.width && sel.width > hSpec.smallMaxWidth && hSpec.small.includes(h)) {\n        available = false;\n        reason = `Niet beschikbaar boven ${hSpec.smallMaxWidth}mm breedte`;\n      }\n      // Rule 8: cable guidance → no concealed housing\n      if (sel.guidanceType === 'cable' && h === 'concealed') {\n        available = false;\n        reason = 'Inbouwkast niet mogelijk met kabelgeleiding';\n      }\n      return { code: h, available, reason };\n    });\n    if (sel.housingType) {\n      const hOpt = availableOptions.housingType.find(h => h.code === sel.housingType);\n      if (hOpt && !hOpt.available) resetFields.push('housingType');\n    }\n  }\n\n  // mountType: concealed housing → not ceiling (rule 14)\n  const allMounts = ['face','top','ceiling','recess'];\n  availableOptions.mountType = allMounts.map(m => {\n    let available = true;\n    let reason = null;\n    if (sel.housingType === 'concealed' && m === 'ceiling') {\n      available = false;\n      reason = 'Plafondmontage niet mogelijk bij inbouwkast';\n    }\n    return { code: m, available, reason };\n  });\n  if (sel.mountType) {\n    const mOpt = availableOptions.mountType.find(m => m.code === sel.mountType);\n    if (mOpt && !mOpt.available) resetFields.push('mountType');\n  }\n\n  // ── STEP 4: Guidance ────────────────────────────────────────────────\n\n  // guidanceType: ZIP screen → only zip (rule 5)\n  const allGuidance = ['zip','cable','free_hanging'];\n  const allowedGuidance = variantSpec.allowedGuidanceTypes || allGuidance;\n  availableOptions.guidanceType = allGuidance.map(g => {\n    let available = allowedGuidance.includes(g);\n    let reason = null;\n    if (!available) reason = `Niet beschikbaar voor ${variant} variant`;\n    return { code: g, available, reason };\n  });\n  if (sel.guidanceType && !allowedGuidance.includes(sel.guidanceType)) {\n    resetFields.push('guidanceType', 'bottomBar', 'sideChannelColor');\n  }\n\n  // sideChannelColor: match frame or limited set per guidance\n  const sideColors = ['RAL9010','RAL9016','RAL7016','RAL7035','RAL7021','RAL9005','DB703','RAL8019'];\n  availableOptions.sideChannelColor = sideColors.map(c => ({\n    code: c, available: true, reason: null\n  }));\n\n  // bottomBar: depends on guidance type (rules 7)\n  if (sel.guidanceType && specs?.guidance?.compatibility) {\n    const gSpec = specs.guidance.compatibility[sel.guidanceType];\n    const allowedBars = gSpec ? gSpec.bottomBars : ['flat','round','weighted','zip'];\n    const allBars = ['flat','round','weighted','zip'];\n    availableOptions.bottomBar = allBars.map(b => ({\n      code: b,\n      available: allowedBars.includes(b),\n      reason: allowedBars.includes(b) ? null : `Niet compatibel met ${sel.guidanceType} geleiding`\n    }));\n    if (sel.bottomBar && !allowedBars.includes(sel.bottomBar)) {\n      resetFields.push('bottomBar');\n    }\n  }\n\n  // ── STEP 5: Drive ───────────────────────────────────────────────────\n\n  // driveType: variant-dependent (rules 5, 6, 15)\n  const allDrives = ['motor','spring_assist','manual_chain'];\n  const allowedDrives = variantSpec.allowedDriveTypes || allDrives;\n  availableOptions.driveType = allDrives.map(d => {\n    let available = allowedDrives.includes(d);\n    let reason = null;\n    if (!available) {\n      reason = `Niet beschikbaar voor ${variant} variant`;\n    }\n    // Rule 15: spring assist not above 4m²\n    if (d === 'spring_assist' && area > 4.0) {\n      available = false;\n      reason = `Veerassistentie niet beschikbaar boven 4m² (huidig: ${area.toFixed(1)}m²)`;\n    }\n    return { code: d, available, reason };\n  });\n  if (sel.driveType) {\n    const dOpt = availableOptions.driveType.find(d => d.code === sel.driveType);\n    if (dOpt && !dOpt.available) resetFields.push('driveType', 'motorBrand', 'motorType', 'controlType');\n  }\n\n  // motorBrand: visible only when motor selected\n  if (sel.driveType === 'motor') {\n    availableOptions.motorBrand = [\n      { code: 'somfy', available: true, reason: null },\n      { code: 'simu', available: true, reason: null },\n      { code: 'becker', available: true, reason: null }\n    ];\n  }\n\n  // motorType: filter by brand (rule 9) + size/torque (rule 11)\n  if (sel.driveType === 'motor' && specs?.motors) {\n    const weightPerM2 = sel.fabricType && specs?.fabric?.[sel.fabricType] ? specs.fabric[sel.fabricType].weightPerM2 : 0.45;\n    const totalWeight = area * weightPerM2;\n    const safetyFactor = specs?.motor?.minTorque?.safetyFactor || 1.3;\n    const reqTorque = totalWeight * 0.05 * safetyFactor;\n\n    availableOptions.motorType = specs.motors.map(m => {\n      let available = true;\n      let reason = null;\n      // Rule 9: brand filter\n      if (sel.motorBrand && m.brand.toLowerCase() !== sel.motorBrand.toLowerCase()) {\n        available = false;\n        reason = 'Ander merk';\n      }\n      // Rule 11: torque requirement\n      if (area > 0 && m.torqueNm < reqTorque) {\n        available = false;\n        reason = `Onvoldoende koppel (${m.torqueNm}Nm < ${reqTorque.toFixed(1)}Nm benodigd)`;\n      }\n      if (area > 0 && m.maxSurfaceM2 && area > m.maxSurfaceM2) {\n        available = false;\n        reason = `Oppervlakte te groot (${area.toFixed(1)}m² > ${m.maxSurfaceM2}m² max)`;\n      }\n      return { code: m.code, available, reason };\n    });\n    if (sel.motorType) {\n      const mtOpt = availableOptions.motorType.find(m => m.code === sel.motorType);\n      if (mtOpt && !mtOpt.available) resetFields.push('motorType', 'controlType');\n    }\n  }\n\n  // controlType: filter by motor brand (rule 10)\n  if (sel.driveType === 'motor') {\n    const allControls = [\n      { code: 'io_homecontrol', label: 'IO Homecontrol' },\n      { code: 'rts', label: 'RTS' },\n      { code: 'rts_timer', label: 'RTS Timer' },\n      { code: 'wired_switch', label: 'Bedrade schakelaar' },\n      { code: 'wired_timer', label: 'Bedrade timer' }\n    ];\n    // Rule 10: Somfy IO motors → io_homecontrol only\n    const selectedMotor = sel.motorType || '';\n    const isSomfyIO = selectedMotor.startsWith('SOMFY-IO');\n    const isSomfyRTS = selectedMotor.startsWith('SOMFY-RTS');\n\n    availableOptions.controlType = allControls.map(ct => {\n      let available = true;\n      let reason = null;\n      if (isSomfyIO && ct.code !== 'io_homecontrol') {\n        available = false;\n        reason = 'Somfy IO motoren vereisen IO Homecontrol';\n      }\n      if (isSomfyRTS && !['rts','rts_timer'].includes(ct.code)) {\n        available = false;\n        reason = 'Somfy RTS motoren alleen met RTS besturing';\n      }\n      if (selectedMotor.startsWith('BECKER') && !['wired_switch','wired_timer'].includes(ct.code)) {\n        available = false;\n        reason = 'Becker motoren alleen met bedrade besturing';\n      }\n      if (selectedMotor.startsWith('SIMU') && !['wired_switch','wired_timer'].includes(ct.code)) {\n        available = false;\n        reason = 'Simu motoren alleen met bedrade besturing';\n      }\n      return { code: ct.code, available, reason };\n    });\n    if (sel.controlType) {\n      const ctOpt = availableOptions.controlType.find(c => c.code === sel.controlType);\n      if (ctOpt && !ctOpt.available) resetFields.push('controlType');\n    }\n  }\n\n  // ── STEP 6: Automation & Extras ─────────────────────────────────────\n\n  // windAutomation: requires motor (rule 12)\n  const windOpts = ['none','eolis_wirefree','eolis_rts','sunis_wirefree'];\n  availableOptions.windAutomation = windOpts.map(w => {\n    let available = true;\n    let reason = null;\n    if (w !== 'none' && sel.driveType !== 'motor') {\n      available = false;\n      reason = 'Windautomatisering vereist motoraandrijving';\n    }\n    return { code: w, available, reason };\n  });\n\n  // remoteControl: requires motor + matching control\n  const remoteOpts = ['none','situo_1ch','situo_5ch','smoove'];\n  availableOptions.remoteControl = remoteOpts.map(r => {\n    let available = true;\n    let reason = null;\n    if (r !== 'none' && sel.driveType !== 'motor') {\n      available = false;\n      reason = 'Afstandsbediening vereist motoraandrijving';\n    }\n    return { code: r, available, reason };\n  });\n\n  // integration: Tahoma requires io_homecontrol (rule 13)\n  const integrationOpts = ['none','tahoma','connexoon'];\n  availableOptions.integration = integrationOpts.map(i => {\n    let available = true;\n    let reason = null;\n    if (i !== 'none' && sel.driveType !== 'motor') {\n      available = false;\n      reason = 'Domotica vereist motoraandrijving';\n    }\n    if (i === 'tahoma' && sel.controlType && sel.controlType !== 'io_homecontrol') {\n      available = false;\n      reason = 'TaHoma vereist IO Homecontrol besturing';\n    }\n    if (i === 'connexoon' && sel.controlType && sel.controlType !== 'io_homecontrol') {\n      available = false;\n      reason = 'Connexoon vereist IO Homecontrol besturing';\n    }\n    return { code: i, available, reason };\n  });\n\n  return { availableOptions, resetFields };\n};"
      }
    },
    {
      "id": "scr-opt-output",
      "name": "Output",
      "type": "outputNode",
      "position": {
        "x": 700,
        "y": 300
      }
    }
  ],
  "edges": [
    {
      "id": "scr-opt-edge-1",
      "sourceId": "scr-opt-input",
      "targetId": "scr-opt-fn"
    },
    {
      "id": "scr-opt-edge-2",
      "sourceId": "scr-opt-fn",
      "targetId": "scr-opt-output"
    }
  ]
}
